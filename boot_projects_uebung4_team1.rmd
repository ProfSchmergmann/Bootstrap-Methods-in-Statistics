---
title: "boot_projects_uebung3_team1"
author: "Sven Bergmann, Malte Lennartz"
date: "`r Sys.Date()`"
output:
html_document:
df_print: paged
---

## 4. Aufgabe
```{r}
table <- as.matrix(read.csv('aufgabe4.csv', header = FALSE))
```
```{r}
Teststatistik <- function(table, mu_0) {
  # Anzahl der Daten der jeweiligen Stichprobe
  n_i <- apply(X = table, MARGIN = 2, FUN = function(x) sum(!is.na(x)))

  # Geschätzte Standardabweichung innerhalb der jeweiligen Stichproben
  s_i_dach <- apply(X = table, MARGIN = 2, FUN = function(x) sd(x[!is.na(x)]))

  # Geschätzter Erwartungswert innerhalb der jeweiligen Stichproben
  mu_i_dach <- apply(X = table, MARGIN = 2, FUN = function(x) mean(x[!is.na(x)]))

  # Teststatistik berechnen:
  omega <- n_i / s_i_dach^2
  mu_0_dach <- sum(omega * mu_i_dach) / sum(omega)

  # Je kleiner die Statistik, d.h. je näher der Wert mu_i_dach am Wert mu_0_dach liegt, desto wahrscheinlicher wird die Hypothese
  T <- sum(omega * (mu_i_dach - mu_0_dach)^2)
  return(list(n_i = n_i, s_i_dach = s_i_dach, omega = omega, mu_i_dach = mu_i_dach, mu_0_dach = mu_0_dach, T = T))
}
```
```{r}
bootstrap <- function(table, m = 1000) {
  # Statistik und andere nützliche Werte der Originaldaten berechnen
  statistik <- Teststatistik(table)
  mu_i_dach <- statistik$mu_i_dach
  s_i_dach <- statistik$s_i_dach
  n_i <- statistik$n_i

  # Anzahl Spalten der Originaldaten
  spalten <- length(n_i)

  # Matrix für die Residuen erstellen
  epsilon <- matrix(ncol = spalten, nrow = max(n_i))
  # Epsilon nach der gegebenen Formel berechnen: (x_ij - mu_i) / sigma_i
  for (spalte in 1:spalten) {
    epsilon[, spalte] <- (table[, spalte] - mu_i_dach[spalte]) / s_i_dach[spalte]
  }

  # Residuen zentrieren, damit diese N(0,1)-verteilt sind
  epsilon <- apply(X = epsilon, MARGIN = 2, FUN = function(x) x - mean(x[!is.na(x)]))

  # Residuen für jede Spalte bootstrappen, sodass die Anzahl der Epsilons innerhalb der Spalten gleich bleibt
  epsilon_boot <- replicate(n = m,
                            expr = sapply(X = 1:spalten,
                                          FUN = function(spalte)
                                            as.numeric(
                                              c(
                                                # Bootstrapziehung der jeweiligen Spalte
                                                sample(x = epsilon[, spalte][!is.na(epsilon[, spalte])],
                                                       replace = TRUE,
                                                       size = n_i[spalte]),
                                                # Auffüllen mit "NA"
                                                replicate(max(n_i) - n_i[spalte],
                                                          NA)
                                              )
                                            )
                            )
  )

  # Reshape der mu_i und s_i
  mu_i_matrix <- matrix(mu_i_dach, nrow = max(n_i), ncol = length(mu_i_dach), byrow = TRUE)
  s_i_matrix <- matrix(s_i_dach, nrow = max(n_i), ncol = length(s_i_dach), byrow = TRUE)

  # Zusammenbauen der X_ij mit der epsilon_boot matrix, sowie der beiden mu_i und s_i Matrizen
  X_boot <- lapply(X = 1:m, FUN = function(idx) epsilon_boot[, , idx] * s_i_matrix + mu_i_matrix)

  # Erstellung der Liste der Statistiken der gebootstrapten X
  statistiken <- list()
  for (matrix_num in 1:m) {
    # Berechnung der Teststatistiken für jede Bootstrap-Wiederholung
    statistiken[matrix_num] <- Teststatistik(as.data.frame(X_boot[matrix_num]))$T
  }

  # Rückgabe der Liste der Statistiken
  return(statistiken)
}
```
```{r}
# Berechnung des p-Wertes, indem die Teststatistik über die Testdaten mit den Statistiken der gebootstrapten Daten verglichen wird.
p_value <- mean(Teststatistik(table)$T < bootstrap(table, 1000))
print(p_value)
```
